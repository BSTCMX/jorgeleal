{
  "order": 5,
  "title": "PixMinder",
  "descriptionEs": "Servicio inteligente de optimización de imágenes construido con Rust implementando Clean Architecture (Arquitectura Hexagonal). Alternativa CDN de alto rendimiento diseñada para reemplazar la optimización nativa de Cloudinary con mejor control, compresión superior y detección inteligente de contexto. Actualmente sirviendo imágenes optimizadas para Qubly CRM y LaZalza con 15-30% mejor compresión y latencia de caché sub-10ms.\n\nBackend en Rust con framework Axum implementando Clean Architecture: separación estricta de capas (domain → application → infrastructure), inyección de dependencias con traits para testabilidad, cero dependencias externas en capa de dominio. Capa de dominio contiene lógica de negocio pura (modelos, servicios, ports como traits), capa de aplicación orquesta casos de uso (OptimizeImageUseCase, GenerateMetricsUseCase, GetCachedImageUseCase), y capa de infraestructura implementa adaptadores externos (handlers HTTP, base de datos, caché, procesamiento de imágenes, integraciones third-party). Todas las preocupaciones transversales aisladas en capa compartida (config, errors, observability).\n\nSistema de caché multi-capa para rendimiento óptimo: caché L1 en memoria con Moka (evicción LRU, 1000 entradas, TTL 5 minutos) logrando latencia <10ms (95% más rápido que red), caché L2 persistente en PostgreSQL (Neon serverless) para compartir entre instancias con limpieza automática de entradas antiguas, y caché L3 Redis (Upstash) con soporte TLS para caché distribuido. Generación de claves de caché usando hash SHA-256 de URL + dimensiones + calidad + formato + contexto de cliente, asegurando entradas únicas por combinación navegador/dispositivo. Invalidación inteligente de caché en cambios de formato y políticas de evicción automáticas.\n\nProcesamiento avanzado de imágenes con encoders específicos por formato: codificación JPEG con MozJPEG para soporte de parámetro de calidad (0-100 configurable), codificación WebP lossy con control de calidad usando crate webp (image crate solo soporta lossless), codificación AVIF con ravif (encoder AVIF puro en Rust) para soporte de formato next-gen, y optimización PNG con reducción automática de paleta. Redimensionamiento inteligente con preservación de aspect ratio: cálculo automático de altura cuando solo se provee ancho, cálculo automático de ancho cuando solo se provee altura, escalado proporcional manteniendo aspect ratio original, y redondeo configurable de dimensiones para eficiencia de caché.\n\nSistema inteligente de detección de contexto de cliente: parsing de HTTP Client Hints (DPR para device pixel ratio, Viewport-Width para píxeles CSS, Width para píxeles físicos incluyendo DPR, Save-Data para detección de velocidad de conexión), parsing de header Accept para detección de capacidad de formato (AVIF, WebP, JPEG, PNG ordenados por preferencia), parsing de User-Agent con Woothee para detección de tipo de dispositivo (mobile, tablet, desktop), y validación automática de formato con FormatCapabilityMatrix asegurando compatibilidad de navegador (Safari iOS < 14 fallback a JPEG, Safari iOS 14-15.3 soporta solo WebP, Safari iOS 16+ soporta AVIF). Struct ClientContext agrega toda la información detectada para decisiones de optimización: vector de formatos soportados ordenados por preferencia, tipo de dispositivo para cálculo de dimensiones, flag save_data para ajuste de calidad, DPR para soporte de displays high-DPI, viewport width para dimensionamiento responsive, y cálculo de ancho efectivo priorizando Width header > viewport * DPR > viewport.\n\nOptimización adaptativa de calidad basada en contexto: calidad base desde parámetro de request (default 85), reducción para modo Save-Data (-15 calidad para ahorro de datos), reducción para conexiones lentas inferidas desde tipo de dispositivo, y ajustes de calidad específicos por formato (AVIF puede usar menor calidad para mismo resultado visual). Optimización de dimensiones con awareness de DPR: upscaling automático para displays high-DPI (2x, 3x), dimensionamiento basado en viewport para imágenes responsive, y redondeo configurable de dimensiones para mejores tasas de cache hit.\n\nIntegración con Cloudinary con bypass completo: CloudinaryAdapter implementa trait ExternalOptimizer, build_original_url construye URLs para obtener imágenes sin procesar desde Cloudinary, fetch_original recupera datos de imagen raw bypaseando la optimización de Cloudinary, y PixMinder procesa imágenes originales con compresión superior. Esta arquitectura permite migración gradual desde Cloudinary manteniendo compatibilidad.\n\nOptimizaciones de rendimiento: patrón Singleflight para prevenir requests concurrentes duplicados para misma imagen (deduplicación), semáforo adaptativo para control de concurrencia con ajuste dinámico basado en carga del sistema, async/await en todo el código para I/O no bloqueante, operaciones zero-copy donde sea posible, y gestión eficiente de memoria con sistema de ownership de Rust. Observabilidad con logging estructurado usando crate tracing, tracking de request span para distributed tracing, colección detallada de métricas (cache hit rate, optimization time, compression ratio, format distribution), y manejo comprehensivo de errores con tipos de error custom.\n\nSistema de autenticación y autorización: generación de tokens JWT con secret y expiración configurables, hashing de contraseñas con Argon2 para almacenamiento seguro de credenciales, autenticación basada en cookies con flags HttpOnly y Secure, rutas protegidas con middleware de verificación de token, y gestión de usuarios con persistencia en PostgreSQL. Dashboard administrativo con visualización de métricas: contador total de optimizaciones, porcentaje de cache hit rate, tiempo promedio de optimización, gráficos de distribución de formato con Chart.js, y estadísticas en tiempo real con caché inteligente (TTL 5 minutos).\n\nEsquema de base de datos con migraciones SQLx: tabla optimizations rastreando todas las imágenes procesadas (id, url, original_size, optimized_size, format, dimensions, quality, created_at), tabla users para autenticación (id, email, password_hash, created_at, updated_at), soft delete automático para auditoría, índices optimizados para rendimiento de queries, y relaciones foreign key para integridad referencial. Connection pooling con tamaño de pool configurable y health checks automáticos de conexión.\n\nEndpoints API: GET /optimize para optimización de imagen con query parameters (url, w, h, q, format), GET /health para health check básico, GET /ready para readiness check validando conexiones de base de datos y caché, GET /metrics para métricas y estadísticas del servicio, POST /auth/login para autenticación, y GET /dashboard para interfaz administrativa (protegida). Configuración CORS con orígenes permitidos configurables soportando múltiples dominios, allowance automático de headers Client Hints (DPR, Viewport-Width, Width, Save-Data), y headers Vary para comportamiento correcto de caché.\n\nModo pass-through para SVG: detección automática de archivos SVG por extensión y Content-Type, proxy directo sin procesamiento (SVGs ya están optimizados), headers Content-Type apropiados (image/svg+xml), y headers de caché para eficiencia de CDN. Manejo de errores con tipos AppError custom: errores Validation para requests inválidos, errores NotFound para imágenes faltantes, errores Processing para fallos de optimización de imagen, y errores External para fallos de servicios third-party. Logging comprehensivo en todos los niveles con salida JSON estructurada en producción.\n\nWorkflow de desarrollo optimizado con Makefile: make check-fast para validación rápida (1-2s con cargo check), make test-fast para solo unit tests (3-5s), make test-integration para integration tests, make build-dev para builds de desarrollo, make run-dev para ejecutar servidor, y make dev para workflow completo (check → test → build → run). Estrategia de testing con 23 unit tests cubriendo lógica de dominio, integration tests para validación end-to-end, test helpers para setup de base de datos, y mock implementations para dependencias externas.\n\nDeploy con Docker usando multi-stage builds: stage builder con Rust 1.75+ y cargo chef para caché de dependencias, stage runtime con Alpine Linux para tamaño mínimo de imagen (~80MB), migraciones automáticas en startup, configuración de health check para orquestación, y caché optimizado de layers para rebuilds rápidos. Deploy en Fly.io con rolling updates zero-downtime, configuración de auto-scaling, monitoreo de health check (endpoint /health cada 10s), gestión de secrets para configuración sensible, y deploy regional (Dallas, Texas).\n\nFeatures de seguridad: HTTPS-only en producción con redirect automático, security headers (X-Content-Type-Options: nosniff, X-Frame-Options: DENY, Strict-Transport-Security con max-age 1 año), rate limiting con thresholds configurables, detección de bots con análisis de User-Agent, y validación de input en todos los entry points. Configuración basada en environment con defaults sensibles, todas las settings configurables vía variables de entorno, detección automática de environment (development vs production), y validación comprehensiva en startup.\n\nFeatures clave: auto-detección de formato desde header Accept con fallback a JPEG, optimización de calidad basada en velocidad de conexión y tipo de dispositivo, cálculo de dimensiones con preservación de aspect ratio, validación de compatibilidad de navegador previniendo mismatches de formato, arquitectura cache-first con fallback multi-capa, bypass de Cloudinary para compresión superior, soporte de Client Hints para dimensionamiento óptimo, pass-through de SVG para gráficos vectoriales, métricas y observabilidad para monitoreo, y dashboard administrativo para analytics.\n\nOptimizaciones validadas en producción: mejora de Lighthouse Performance +7-13 puntos, reducción de LCP de 300-600ms, reducción de tamaño de imagen de 25-33%, latencia de caché <10ms (95% más rápido que red), compresión 15-30% mejor que Cloudinary nativo, y cero breaking changes durante migración. Actualmente sirviendo Qubly CRM (SvelteKit + Go) y LaZalza (Next.js 14) con loaders custom para integración seamless.\n\nStack: Rust 1.75+, Axum 0.8, Tokio (async runtime), Tower (middleware), PostgreSQL (Neon serverless), SQLx (async ORM), Redis (Upstash con TLS), Moka (in-memory cache), image crate, MozJPEG, WebP, ravif (AVIF), Woothee (browser detection), Tera (templates), Chart.js, Tracing (observability), Docker, Fly.io. Deploy automatizado en Fly.io con health checks, migraciones automáticas, y rolling updates zero-downtime.",
  "descriptionEn": "Intelligent image optimization service built with Rust implementing Clean Architecture (Hexagonal Architecture). High-performance CDN alternative designed to replace Cloudinary's native optimization with better control, superior compression, and intelligent context detection. Currently serving optimized images for Qubly CRM and LaZalza with 15-30% better compression and sub-10ms cache latency.\n\nBackend in Rust with Axum framework implementing Clean Architecture: strict layer separation (domain → application → infrastructure), dependency injection with traits for testability, zero external dependencies in domain layer. Domain layer contains pure business logic (models, services, ports as traits), application layer orchestrates use cases (OptimizeImageUseCase, GenerateMetricsUseCase, GetCachedImageUseCase), and infrastructure layer implements external adapters (HTTP handlers, database, cache, image processing, third-party integrations). All cross-cutting concerns isolated in shared layer (config, errors, observability).\n\nMulti-layer caching system for optimal performance: L1 in-memory cache with Moka (LRU eviction, 1000 entries, 5-minute TTL) achieving <10ms latency (95% faster than network), L2 persistent cache in PostgreSQL (Neon serverless) for cross-instance sharing with automatic cleanup of old entries, and L3 Redis cache (Upstash) with TLS support for distributed caching. Cache key generation using SHA-256 hash of URL + dimensions + quality + format + client context, ensuring unique cache entries per browser/device combination. Intelligent cache invalidation on format changes and automatic eviction policies.\n\nAdvanced image processing with format-specific encoders: JPEG encoding with MozJPEG for quality parameter support (0-100 configurable), WebP lossy encoding with quality control using webp crate (image crate only supports lossless), AVIF encoding with ravif (pure Rust AVIF encoder) for next-gen format support, and PNG optimization with automatic palette reduction. Smart resizing with aspect ratio preservation: automatic height calculation when only width provided, automatic width calculation when only height provided, proportional scaling maintaining original aspect ratio, and configurable dimension rounding for cache efficiency.\n\nIntelligent client context detection system: HTTP Client Hints parsing (DPR for device pixel ratio, Viewport-Width for CSS pixels, Width for physical pixels including DPR, Save-Data for connection speed detection), Accept header parsing for format capability detection (AVIF, WebP, JPEG, PNG ordered by preference), User-Agent parsing with Woothee for device type detection (mobile, tablet, desktop), and automatic format validation with FormatCapabilityMatrix ensuring browser compatibility (Safari iOS < 14 fallback to JPEG, Safari iOS 14-15.3 supports WebP only, Safari iOS 16+ supports AVIF). ClientContext struct aggregates all detected information for optimization decisions: supported formats vector ordered by preference, device type for dimension calculation, save_data flag for quality adjustment, DPR for high-DPI display support, viewport width for responsive sizing, and effective width calculation prioritizing Width header > viewport * DPR > viewport.\n\nAdaptive quality optimization based on context: base quality from request parameter (default 85), reduction for Save-Data mode (-15 quality for data saving), reduction for slow connections inferred from device type, and format-specific quality adjustments (AVIF can use lower quality for same visual result). Dimension optimization with DPR awareness: automatic upscaling for high-DPI displays (2x, 3x), viewport-based sizing for responsive images, and configurable dimension rounding for better cache hit rates.\n\nCloudinary integration with complete bypass: CloudinaryAdapter implements ExternalOptimizer trait, build_original_url constructs URLs to fetch unprocessed images from Cloudinary, fetch_original retrieves raw image data bypassing Cloudinary's optimization, and PixMinder processes original images with superior compression. This architecture allows gradual migration from Cloudinary while maintaining compatibility.\n\nPerformance optimizations: Singleflight pattern to prevent duplicate concurrent requests for same image (deduplication), adaptive semaphore for concurrency control with dynamic adjustment based on system load, async/await throughout for non-blocking I/O, zero-copy operations where possible, and efficient memory management with Rust's ownership system. Observability with structured logging using tracing crate, request span tracking for distributed tracing, detailed metrics collection (cache hit rate, optimization time, compression ratio, format distribution), and comprehensive error handling with custom error types.\n\nAuthentication and authorization system: JWT token generation with configurable secret and expiration, Argon2 password hashing for secure credential storage, cookie-based authentication with HttpOnly and Secure flags, protected routes with token verification middleware, and user management with PostgreSQL persistence. Administrative dashboard with metrics visualization: total optimizations count, cache hit rate percentage, average optimization time, format distribution charts with Chart.js, and real-time statistics with intelligent caching (5-minute TTL).\n\nDatabase schema with SQLx migrations: optimizations table tracking all processed images (id, url, original_size, optimized_size, format, dimensions, quality, created_at), users table for authentication (id, email, password_hash, created_at, updated_at), automatic soft delete for auditing, optimized indexes for query performance, and foreign key relationships for referential integrity. Connection pooling with configurable pool size and automatic connection health checks.\n\nAPI endpoints: GET /optimize for image optimization with query parameters (url, w, h, q, format), GET /health for basic health check, GET /ready for readiness check validating database and cache connections, GET /metrics for service metrics and statistics, POST /auth/login for authentication, and GET /dashboard for administrative interface (protected). CORS configuration with configurable allowed origins supporting multiple domains, automatic Client Hints headers allowance (DPR, Viewport-Width, Width, Save-Data), and Vary headers for proper cache behavior.\n\nSVG pass-through mode: automatic detection of SVG files by extension and Content-Type, direct proxy without processing (SVGs are already optimized), proper Content-Type headers (image/svg+xml), and cache headers for CDN efficiency. Error handling with custom AppError types: Validation errors for invalid requests, NotFound errors for missing images, Processing errors for image optimization failures, and External errors for third-party service failures. Comprehensive logging at all levels with structured JSON output in production.\n\nDevelopment workflow optimized with Makefile: make check-fast for quick validation (1-2s with cargo check), make test-fast for unit tests only (3-5s), make test-integration for integration tests, make build-dev for development builds, make run-dev for running server, and make dev for complete workflow (check → test → build → run). Testing strategy with 23 unit tests covering domain logic, integration tests for end-to-end validation, test helpers for database setup, and mock implementations for external dependencies.\n\nDocker deployment with multi-stage builds: builder stage with Rust 1.75+ and cargo chef for dependency caching, runtime stage with Alpine Linux for minimal image size (~80MB), automatic migrations on startup, health check configuration for orchestration, and optimized layer caching for fast rebuilds. Fly.io deployment with zero-downtime rolling updates, automatic scaling configuration, health check monitoring (/health endpoint every 10s), secrets management for sensitive configuration, and regional deployment (Dallas, Texas).\n\nSecurity features: HTTPS-only in production with automatic redirect, security headers (X-Content-Type-Options: nosniff, X-Frame-Options: DENY, Strict-Transport-Security with 1-year max-age), rate limiting with configurable thresholds, bot detection with User-Agent analysis, and input validation at all entry points. Environment-based configuration with sensible defaults, all settings configurable via environment variables, automatic environment detection (development vs production), and comprehensive validation on startup.\n\nKey features: format auto-detection from Accept header with fallback to JPEG, quality optimization based on connection speed and device type, dimension calculation with aspect ratio preservation, browser compatibility validation preventing format mismatches, cache-first architecture with multi-layer fallback, Cloudinary bypass for superior compression, Client Hints support for optimal sizing, SVG pass-through for vector graphics, metrics and observability for monitoring, and administrative dashboard for analytics.\n\nOptimizations validated in production: Lighthouse Performance +7-13 points improvement, LCP reduction of 300-600ms, image size reduction of 25-33%, cache latency <10ms (95% faster than network), compression 15-30% better than Cloudinary native, and zero breaking changes during migration. Currently serving Qubly CRM (SvelteKit + Go) and LaZalza (Next.js 14) with custom loaders for seamless integration.\n\nStack: Rust 1.75+, Axum 0.8, Tokio (async runtime), Tower (middleware), PostgreSQL (Neon serverless), SQLx (async ORM), Redis (Upstash with TLS), Moka (in-memory cache), image crate, MozJPEG, WebP, ravif (AVIF), Woothee (browser detection), Tera (templates), Chart.js, Tracing (observability), Docker, Fly.io. Automated deployment on Fly.io with health checks, automatic migrations, and zero-downtime rolling updates.",
  "video": "/videos/pixminder.webm",
  "poster": "/images/posters/pixminderposter.webp",
  "tags": ["Rust", "Axum", "PostgreSQL", "Redis", "Cloudinary", "Moka", "Fly.io"]
}
